#!/usr/bin/env bash
# ipcheck v0.7.3

VERSION="0.7.3"
UPDATE_URL="https://raw.githubusercontent.com/vespovios/ipcheck-cli/main/VERSION"
BASE_URL_AUTO="https://get.geojs.io/v1/ip/geo.json"
BASE_URL_IP="https://get.geojs.io/v1/ip/geo"
CACHE_TTL=300            # seconds (5 minutes)

# -------- Flags --------
SHORT=0
RAW=0
RAW_PRETTY=0
QUIET=0
NOFLAG=0
CHECK_UPDATE=0
TARGET_IP=""

# color enabled if stdout is a terminal
use_color=1
if [[ ! -t 1 ]]; then
  use_color=0
fi

# -------- Helpers --------

show_help() {
  cat << EOF
ipcheck v${VERSION}

Usage: ipcheck [OPTIONS]

Fetch and display public IP geolocation information (using geojs.io).

Options:
  -i, --ip IP        Look up a specific IP instead of your own
  -s, --short        Show short output (IP, country, flag)
  -r, --raw          Output raw JSON from the API
      --raw-pretty   Output pretty-printed JSON
  -q, --quiet        Output only the IP address
      --no-flag      Disable country flag emoji
      --check-update Check for a newer ipcheck version (if UPDATE_URL is set)
  -h, --help         Show this help message and exit

Examples:
  ipcheck
  ipcheck --short
  ipcheck --quiet
  ipcheck --ip 8.8.8.8
  ipcheck --raw-pretty
EOF
}

country_code_to_flag() {
  local cc="${1^^}"
  if [[ ${#cc} -ne 2 ]]; then echo ""; return; fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$cc" << 'PY'
import sys
cc = sys.argv[1].upper()
base = 0x1F1E6
print(''.join(chr(base + ord(c) - ord('A')) for c in cc))
PY
  else
    echo "$cc"
  fi
}

install_hint() {
  if command -v apt >/dev/null 2>&1; then
    echo "Try: sudo apt install $*"
  fi
}

cache_file_for_ip() {
  local key="$1"
  [[ -z "$key" ]] && key="auto"
  key=${key//[^0-9A-Za-z_.-]/_}
  echo "/tmp/ipcheck_cache_${key}.txt"
}

fetch_response_with_cache() {
  local ip="$1"
  local url=""
  if [[ -n "$ip" ]]; then
    url="${BASE_URL_IP}/${ip}.json"
  else
    url="$BASE_URL_AUTO"
  fi

  local cache_file
  cache_file=$(cache_file_for_ip "$ip")
  local now ts

  now=$(date +%s)

  if [[ -f "$cache_file" ]]; then
    read -r ts < "$cache_file"
    if [[ "$ts" =~ ^[0-9]+$ ]] && (( now - ts < CACHE_TTL )); then
      response=$(tail -n +2 "$cache_file")
      return
    fi
  fi

  response=$(curl -s "$url")
  if [[ -n "$response" ]]; then
    printf '%s\n%s\n' "$now" "$response" > "$cache_file"
  fi
}

# Return -1 if a<b, 0 if a==b, 1 if a>b
compare_versions() {
  local a="$1" b="$2"
  local IFS='.' av bv
  read -ra av <<< "$a"
  read -ra bv <<< "$b"

  local len=${#av[@]}
  (( ${#bv[@]} > len )) && len=${#bv[@]}

  for ((i=0; i<len; i++)); do
    local x=${av[i]:-0}
    local y=${bv[i]:-0}
    ((10#$x < 10#$y)) && { echo -1; return; }
    ((10#$x > 10#$y)) && { echo 1; return; }
  done
  echo 0
}

check_update() {
  if [[ -z "$UPDATE_URL" ]]; then
    echo "Update check: UPDATE_URL is not configured in this script."
    return 0
  fi

  local latest
  latest=$(curl -m 3 -fsS "$UPDATE_URL" 2>/dev/null | head -n1 | tr -d ' \r\n') || {
    echo "Update check: could not contact update server."
    return 0
  }

  if [[ -z "$latest" ]]; then
    echo "Update check: received empty/invalid response from update URL."
    return 0
  fi

  local cmp
  cmp=$(compare_versions "$VERSION" "$latest")

  if [[ "$cmp" == "0" ]]; then
    echo "ipcheck is up to date (version $VERSION)."
  elif [[ "$cmp" == "-1" ]]; then
    echo "A newer ipcheck is available: $latest (you have $VERSION)."
  else
    echo "Your local ipcheck ($VERSION) is newer than the remote version ($latest)."
  fi
}

validate_ip() {
  local ip="$1"
  [[ -z "$ip" ]] && return 0

  # Best case: python3 + ipaddress (handles IPv4 + IPv6)
  if command -v python3 >/dev/null 2>&1; then
    local res
    res=$(python3 - "$ip" << 'PY'
import sys, ipaddress
ip = sys.argv[1]
try:
    ipaddress.ip_address(ip)
    print("OK", end="")
except ValueError:
    print("INVALID", end="")
PY
)
    if [[ "$res" != "OK" ]]; then
      echo "Error: '$ip' is not a valid IP address." >&2
      exit 1
    fi
  else
    # Fallback: simple IPv4 check
    if [[ ! "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
      echo "Warning: Could not strictly validate IP (python3 missing); proceeding with '$ip'." >&2
      return 0
    fi
    local IFS='.' octets=($ip)
    for o in "${octets[@]}"; do
      if (( o < 0 || o > 255 )); then
        echo "Error: '$ip' is not a valid IPv4 address." >&2
        exit 1
      fi
    done
  fi
}

sanitize_field() {
  local v="$1"
  if [[ -z "$v" || "$v" == "null" ]]; then
    echo "N/A"
  else
    echo "$v"
  fi
}

# -------- Argument parsing --------

while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--ip)
      TARGET_IP="$2"
      if [[ -z "$TARGET_IP" ]]; then
        echo "Error: --ip requires an argument." >&2
        exit 1
      fi
      shift 2
      ;;
    -s|--short)
      SHORT=1
      use_color=0
      shift
      ;;
    -r|--raw)
      RAW=1
      use_color=0
      shift
      ;;
    --raw-pretty)
      RAW_PRETTY=1
      use_color=0
      shift
      ;;
    -q|--quiet)
      QUIET=1
      use_color=0
      shift
      ;;
    --no-flag)
      NOFLAG=1
      shift
      ;;
    --check-update)
      CHECK_UPDATE=1
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      echo
      show_help
      exit 1
      ;;
  esac
done

# -------- Colors (finalise after args) --------
if [[ $use_color -eq 1 ]]; then
  RESET="\033[0m"
  BOLD="\033[1m"
  BLUE="\033[34m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
else
  RESET=""
  BOLD=""
  BLUE=""
  GREEN=""
  YELLOW=""
fi

# -------- Dependencies --------
if ! command -v curl >/dev/null 2>&1; then
  echo "Error: curl not installed." >&2
  install_hint curl
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "Error: jq not installed." >&2
  install_hint jq
  exit 1
fi

# Validate IP if provided
validate_ip "$TARGET_IP"

# Explicit update check: only show update info, then exit
if [[ "$CHECK_UPDATE" -eq 1 ]]; then
  check_update
  exit 0
fi

# -------- Fetch data (with cache) --------
response=""
fetch_response_with_cache "$TARGET_IP"

if [[ -z "$response" ]]; then
  echo "Error: No response from API." >&2
  exit 1
fi

# -------- Raw modes --------
if [[ "$RAW" -eq 1 ]]; then
  echo "$response"
  exit 0
fi

if [[ "$RAW_PRETTY" -eq 1 ]]; then
  echo "$response" | jq .
  exit 0
fi

# -------- Parse & sanitize JSON --------
ip=$(echo "$response" | jq -r '.ip')
country=$(echo "$response" | jq -r '.country')
country_code=$(echo "$response" | jq -r '.country_code')

region_raw=$(echo "$response" | jq -r '.region')
city_raw=$(echo "$response" | jq -r '.city')
isp_raw=$(echo "$response" | jq -r '.organization_name')
timezone_raw=$(echo "$response" | jq -r '.timezone')
lat_raw=$(echo "$response" | jq -r '.latitude')
lon_raw=$(echo "$response" | jq -r '.longitude')

region=$(sanitize_field "$region_raw")
city=$(sanitize_field "$city_raw")
isp=$(sanitize_field "$isp_raw")
timezone=$(sanitize_field "$timezone_raw")
lat=$(sanitize_field "$lat_raw")
lon=$(sanitize_field "$lon_raw")

flag=""
if [[ "$NOFLAG" -eq 0 ]]; then
  flag=$(country_code_to_flag "$country_code")
fi

# -------- Quiet mode --------
if [[ "$QUIET" -eq 1 ]]; then
  echo "$ip"
  exit 0
fi

# -------- Short mode --------
if [[ "$SHORT" -eq 1 ]]; then
  if [[ "$NOFLAG" -eq 1 ]]; then
    echo "${ip} - ${country} (${country_code})"
  else
    echo "${ip} - ${country} (${country_code}) ${flag}"
  fi
  exit 0
fi

# -------- Full pretty output --------
printf "\n"
printf "%büåç  %bPublic IP Information%b %s\n" "$BLUE" "$BOLD" "$RESET" "$flag"
printf "%b-----------------------------------------%b\n" "$BLUE" "$RESET"

printf "%bIP Address:%b      %s\n"       "$GREEN" "$RESET" "$ip"
printf "%bCountry:%b         %s (%s)\n" "$GREEN" "$RESET" "$country" "$country_code"
printf "%bRegion:%b          %s\n"       "$GREEN" "$RESET" "$region"
printf "%bCity:%b            %s\n"       "$GREEN" "$RESET" "$city"
printf "%bISP:%b             %s\n"       "$GREEN" "$RESET" "$isp"
printf "%bTimezone:%b        %s\n"       "$YELLOW" "$RESET" "$timezone"
printf "%bLatitude:%b        %s\n"       "$YELLOW" "$RESET" "$lat"
printf "%bLongitude:%b       %s\n"       "$YELLOW" "$RESET" "$lon"
printf "\n"
